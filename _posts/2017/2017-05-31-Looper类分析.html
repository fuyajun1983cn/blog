--- 
layout: post
author: 山庄来客
date:   2016-07-16
update: 2017-05-31
categories: android 
---


<div id="content">
<h1 class="title">Looper类代码分析</h1>
<p>
　　本文将分析一下Looper类的实现及其应用，代码位于
frameworks/native/lib/utils/Looper.cpp。主要分为如下几个部分：
</p>
<ol class="org-ol">
<li>epoll系统调用接口简介
</li>
<li>Looper类代码分析
</li>
<li>Looper类应用实例分析
</li>
</ol>

<p>
<b>一、epoll系统调用接口简介</b>
</p>

<p>
Looper事件机制实际上是依赖系统调用epoll实现的。它是一种I/O复用模型，
即可以同时监控多个I/O事件。对于Looper来说，所谓的I/O事件就是所监控
的文件描述符上没有有数据到达。epoll的主要接口如下所示 ：
</p>
<ol class="org-ol">
<li><code>epoll_create()</code>
创建一个epoll实例，返回引用该实例的文件描述符。
原型如下所示 ：
<pre class="example">
int epoll_create(int size );
</pre>
<p>
参数size指定了我们想通过epoll实例监控文件描述符的数量。
</p>
</li>
<li><code>epoll_ctl()</code>
　　操作与该epoll实例相关联的兴趣列表：添加一个文件描述符到兴趣
列表中，从兴趣列表中删除一个现存的文件描述符以及修改事件掩码以决
定要监控文件描述符上发生的哪个事件。
原型如下所示：
<pre class="example">
int epoll_ctl(int epfd , int op , int fd , struct epoll_event * ev );
</pre>

<p>
其中参数op可以取如下一些值：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">EPOLL_CTL_ADD</th>
<th scope="col" class="left">将fd加入了监控列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">EPOLL_CTL_MOD</td>
<td class="left">修改当前监控的fd相关信息</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">EPOLL_CTL_DEL</td>
<td class="left">将fd从监控列表中删除</td>
</tr>
</tbody>
</table>
</li>
<li><code>epoll_wait()</code>
从I/O Ready列表中返回与epoll实例相关联的项，即返回有事件发生的文
件描述符的数量。
原型如下所示：
<pre class="example">
int epoll_wait(int epfd , struct epoll_event * evlist , int maxevents , int timeout );
</pre>
<p>
其中timeout值为-1时，表示无限等待直到有事件发生。为0时，执行一个
非阻塞检查后立即返回。大于0时，表示一个超时时间值。
</p>

<p>
另外， <code>struct epoll_event</code> 结构定义如下所示 ：
</p>
<div class="org-src-container">

<pre class="src src-c">struct epoll_event {
    uint32_t events;  /* epoll events (bit mask) */
    epoll_data_t data; /* User data */
};
</pre>
</div>

<p>
主要的事件掩码有：
EPOLLIN：代表有数据可读
EPOLLOUT：代表有数据可写
</p>

<p>
<code>epoll_data_t</code> 的数据结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">typedef union epoll_data {
    void *ptr;  /* Pointer to user-defined data */
    int fd;  /*File descriptor */
    uint32_t u32; /* 32-bit integer */
    uint64_t u64; /* 64-bit integer */
} epoll_data_t;
</pre>
</div>

<p>
使用实例:
</p>
<div class="org-src-container">

<pre class="src src-c">int epfd;
struct epoll_event ev;
epfd = epoll_create(5);
if (epfd == -1)
    errExit("epoll_create");
ev.data.fd = fd;
ev.events = EPOLLIN;
if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)
    errExit("epoll_ctl");
...
epoll_wait(...);
</pre>
</div>
</li>
</ol>

<p>
<b>二、Looper类代码分析</b>
</p>

<p>
Looper类定义了一种事件接口，这里所谓的事件就是文件描述符上的I/O数据
是否可读或可写。它提供了一系列接口来支持事件通知和响应，通过轮询，
利用epoll系统调用，可以侦测到发生在文件描述符上的I/O事件。
</p>

<p>
在分析Looper类之前，我们先来看两个与之相关的接口：
</p>
<ol class="org-ol">
<li>Looper消息处理接口。
<div class="org-src-container">

<pre class="src src-c">class MessageHandler : public virtual RefBase {
protected:
    virtual ~MessageHandler() { }

public:
    /**
     * Handles a message.
     */
    virtual void handleMessage(const Message&amp; message) = 0;
};
</pre>
</div>

<p>
与之相关的Looper类的几个成员函数定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">/**
 * Enqueues a message to be processed by the specified handler.
 */
void sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message);

/**
 * Enqueues a message to be processed by the specified handler after all pending messages
 * after the specified delay.
 */
void sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler,
        const Message&amp; message);

/**
 * Enqueues a message to be processed by the specified handler after all pending messages
 * at the specified time.
 */
void sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler,
        const Message&amp; message);

/**
 * Removes all messages for the specified handler from the queue.
 */
void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler);

/**
 * Removes all messages of a particular type for the specified handler from the queue.
 */
void removeMessages(const sp&lt;MessageHandler&gt;&amp; handler, int what);
</pre>
</div>

<p>
　　从上述成员函数的定义可以看到，Looper对MessageHandler都拥有强
引用，所以需要通过显式调用remoeveMessage将其删掉。
</p>

<p>
　　此外，也定义了一个WeakMessageHandler类，它通过一个弱引用来引
用一个MessageHandler对象，在需要的时候强化为强引用。
</p>
</li>

<li>Looper回调函数接口。
回调函数类定义如下：
<div class="org-src-container">

<pre class="src src-c">/**
 * A looper callback.
 */
class LooperCallback : public virtual RefBase {
protected:
    virtual ~LooperCallback() { }

public:
    /**
     * Handles a poll event for the given file descriptor.
     * It is given the file descriptor it is associated with,
     * a bitmask of the poll events that were triggered (typically ALOOPER_EVENT_INPUT),
     * and the data pointer that was originally supplied.
     *
     * Implementations should return 1 to continue receiving callbacks, or 0
     * to have this file descriptor and callback unregistered from the looper.
     */
    virtual int handleEvent(int fd, int events, void* data) = 0;
};
</pre>
</div>

<p>
同样地，也定义了一个辅助类SimpleLooperCallback，它支持接受一个回
调函数指针。
</p>
<pre class="example">
typedef int (*ALooper_callbackFunc)(int fd, int events, void* data);
</pre>

<p>
与之相关的Looper类的成员函数如下所示 ：
</p>
<pre class="example">
int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);
int addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data);
</pre>

<p>
　　这两个成员函数的主要作用是：将要监控的fd加入到Looper的事件监
控列表中。这里，可以指定回调函数。当有事件发生时，Looper实例会自
动调用回调函数。如果回调函数为空，则由调用者处理发生的事件。
</p>

<p>
　　下面将分析Looper类的实现。先分析下成员变量的意义：
</p>

<div class="org-src-container">

<pre class="src src-c++">const bool mAllowNonCallbacks; // immutable

int mWakeReadPipeFd;  // immutable
int mWakeWritePipeFd; // immutable
Mutex mLock;

Vector&lt;MessageEnvelope&gt; mMessageEnvelopes; // guarded by mLock
bool mSendingMessage; // guarded by mLock

int mEpollFd; // immutable

// Locked list of file descriptor monitoring requests.
KeyedVector&lt;int, Request&gt; mRequests;  // guarded by mLock

// This state is only used privately by pollOnce and does not require a lock since
// it runs on a single thread.
Vector&lt;Response&gt; mResponses;
size_t mResponseIndex;
nsecs_t mNextMessageUptime; // set to LLONG_MAX when none
</pre>
</div>

<p>
　　它们的表示的意义如下所示:
　　mAllowNonCallbacks: 表示是否允许将文件描述符加入监控对象时，
指定回调函数为空。
</p>

<p>
　　mWakeReadPipeFd：Looper类默认构造的双向管道的只读端。
</p>

<p>
　　mWakeWritePipeFd：Looper类默认构造的双向管道的只写端。
</p>

<p>
mLock：互斥访问保护锁，主要Looper类的一些成员变量的并发访问。
</p>

<p>
　　mMessageEnvelopes：Looper实例包含的“消息信封”集合。消息信封
主要包含如下属性：时间戳，消息处理函数指针以及消息本身。
</p>

<p>
　　mSendingMessage：当前Looper实例是否正在发送消息。
</p>

<p>
　　mEpollFd：epoll实例对应的描述符。
</p>

<p>
mRequests：当前Looper实例中的文件描述符监控请求。对就的数据结构
struct Request定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c">struct Request {
  int fd;
  int ident;
  sp&lt;LooperCallback&gt; callback;
  void* data;
};
</pre>
</div>

<p>
其中，fd表示监控的文件描述符，ident表示表示监控的事件标识。
callback是事件发生时，对应的回调函数。data为传递给回调函数的自定
义数据。
</p>

<p>
mResponses：当前的响应集合。数据结构Response的定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c">struct Response {
  int events;
  Request request;
};
</pre>
</div>

<p>
mResponseIndex：响应索引号。
</p>

<p>
mNextMessageUptime：下一个消息处理的时间。
</p>

<p>
　　接下来，看构造函数声明：
</p>
<pre class="example">
Looper(bool allowNonCallbacks);
</pre>

<p>
　　参数allowNonCallbacks表示是否允许将文件描述符加入监控对象时，
指定回调函数为空。
</p>

<p>
　　其实现如下所示：
　　首先，它创建了一个双向管道，一端读，一端写。并将其设置为非阻
塞模式。然后创建epoll实例，将只读端管道文件描述符中入到epoll的监
控列表中，这样保护epoll实例中至少包含有一个文件描述符在其事件监
控列表中。详细代码如下所示 ：
</p>

<div class="org-src-container">

<pre class="src src-c++">Looper::Looper(bool allowNonCallbacks) :
  mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
  mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
  int wakeFds[2];
  int result = pipe(wakeFds);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

  mWakeReadPipeFd = wakeFds[0];
  mWakeWritePipeFd = wakeFds[1];

  result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
                      errno);

  result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
                      errno);

  // Allocate the epoll instance and register the wake pipe.
  mEpollFd = epoll_create(EPOLL_SIZE_HINT);
  LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance.  errno=%d", errno);

  struct epoll_event eventItem;
  memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
  eventItem.events = EPOLLIN;
  eventItem.data.fd = mWakeReadPipeFd;
  result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
  LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
                      errno);
}
</pre>
</div>

<p>
　　再来看与线程相关的几个类的静态函数：
</p>
<pre class="example">
static sp&lt;Looper&gt; prepare(int opts);
</pre>
<p>
　　将一个Looper实例与调用者所在的线程关联。Opts的值为： 
　　 <code>ALOOPER_PREPARE_ALLOW_NON_CALLBACKS</code> 或0，它返回该Looper实
例。
</p>

<pre class="example">
static void setForThread(const sp&lt;Looper&gt;&amp; looper);
</pre>
<p>
设置looper对象与当前线程关联。如果当前looper对象已经存在，则替换
掉。如果looper为NULL，则删除当前关联的looper对象。
</p>

<pre class="example">
static sp&lt;Looper&gt; getForThread();
</pre>
<p>
　　返回当前线程关联的Looper实例。
</p>

<p>
接下来看下两个比较重要的成员函数：
</p>
<pre class="example">
int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data)
</pre>
<p>
该函数主要是将fd加入到Looper的事件监控列表中。如果
allowNonCallbacks为false，则必须指定回调函数，且此时ident值为
<code>ALOOPER_POLL_CALLBACK(-2)</code> ，忽略传入的indent的值，而回调函数为空
时，传入的ident值不能小于0 。实际上会通过系统调用epoll<sub>ctl将fd加</sub>
入到epoll实例的事件监控列表中。同时，也记录下此次的监控信息，封
装成一个Request实例，加入到成员变量mRequests当中。如果fd已经存在，
则替换掉旧的Request对象。
</p>

<pre class="example">
void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) 
</pre>
<p>
该函数主要作用就是发送一个Message对象，实现就是注册一个
MessageEnvelop（消息信封）实例，加入到成员变量mMessageEnvelopes，
它是按消息触发的时间排序的。
</p>

<p>
最后，我们来看下它的核心成员函数pollOnce，基本流程图如下所示 ：
<img src="/images/2016/2016073001.jpg" alt="2016073001.jpg" />
</p>

<p>
　　下面来分析上述过程：
</p>
<ol class="org-ol">
<li>Handle response
<div class="org-src-container">

<pre class="src src-c++">for (;;) {
  while (mResponseIndex &lt; mResponses.size()) {
    const Response&amp; response = mResponses.itemAt(mResponseIndex++);
    int ident = response.request.ident;
    if (ident &gt;= 0) {
      int fd = response.request.fd;
      int events = response.events;
      void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
      ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
            "fd=%d, events=0x%x, data=%p",
            this, ident, fd, events, data);
#endif
      if (outFd != NULL) *outFd = fd;
      if (outEvents != NULL) *outEvents = events;
      if (outData != NULL) *outData = data;
      return ident;
    }
  }
</pre>
</div>

<p>
　　针对回调函数为空的情况，ident值必为一个大于等于0的值（注：
有回调函数时，indent的值为-2）。所以上述这段代码只会发生在回
调函数为空的情况，此时将返回发生事件的描述符，发生的事件以及
返回的数据，供调用者进一步处理。
</p>
</li>

<li>Handle result.
<div class="org-src-container">

<pre class="src src-c++">for(;;) {
...
       if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD("%p ~ pollOnce - returning result %d", this, result);
#endif
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }
...
}
</pre>
</div>

<p>
这段代码实际上是根据pollInner的结果进行处理，实际上是针对设置
了回调函数的情况，因为设置了回调函数，所以已经对发生的事件做
了处理了，所以，不需要将发生事件的相关信息再返回给调用者了。
</p>
</li>

<li>pollInner
<div class="org-src-container">

<pre class="src src-c++">for(;;) {
...
 result = pollInner(timeoutMillis);
}
</pre>
</div>

<ol class="org-ol">
<li>Ajust the time out.
<div class="org-src-container">

<pre class="src src-c++">int Looper::pollInner(int timeoutMillis) {
    ...
    // Adjust the timeout based on when the next message is due.
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
　　...
　　}
　　...
}
</pre>
</div>
<p>
　　为什么要调整超时时间值，原因很简单：因为对于消息来说，
可能有多个消息，且每个消息触发的时间点不同，一次事件的触发
导致epoll_wait返回并不能处理完所有的消息，所有会多次调用
epoll_wait函数，由于超时值是第一次调用时指定的，所以再次调
用时，需要重新计算，要去掉已经消耗的时间。代码中now记录当
前的时间值，toMillisecondTimeoutDelya(&#x2026;)计算这本次循环的
超时值。上述的判断条件指明了什么情况下需要做些调整：
</p>
<ul class="org-ul">
<li>当前的消息触发时间不早于当前时间。（即消息没有过时）
</li>

<li>上轮 <code>epoll_wait</code> 指定的超时值为-1或一个较大的数值（&gt;
messageTimeoutMillis）。
</li>
</ul>
</li>

<li>wait for event(epoll wait)
<div class="org-src-container">

<pre class="src src-c++">             ...
             struct epoll_event eventItems[EPOLL_MAX_EVENTS];
         　　int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
         　　...
</pre>
</div>

<p>
主要通过 <code>epoll_wait</code> 系统调用检测事件的发生。
</p>
</li>

<li>handle the event

<div class="org-src-container">

<pre class="src src-c++">...
  for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
                        "no longer registered.", epollEvents, fd);
            }
        }
　　}
　　...
</pre>
</div>

<p>
　　对于Looper对象内置的管道，处理EPOLLIN事件，而对于其他
监听的文件描述符，则分别记录下EPOLLIN， EPOLLOUT，
EPOLLERR， EPOLLHUP并打包成Response对象加入到mResponses中
进行处理。
</p>
</li>

<li>invoke pending message callbacks
<div class="org-src-container">

<pre class="src src-c++">  // Invoke pending message callbacks.
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            // Remove the envelope from the list.
            // We keep a strong reference to the handler until the call to handleMessage
            // finishes.  Then we drop it so that the handler can be deleted *before*
            // we reacquire our lock.
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();

#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
                        this, handler.get(), message.what);
#endif
                handler-&gt;handleMessage(message);
            } // release handler

            mLock.lock();
            mSendingMessage = false;
            result = ALOOPER_POLL_CALLBACK;
        } else {
            // The last message left at the head of the queue determines the next wakeup time.
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }
</pre>
</div>

<p>
messageEnvelope.uptime代表该消息被处理的时机，先处理掉已经
过时的消息，即messageEnvelope.uptime &lt;= now， 如果还有未过
时的消息，则记录下它应该被处理的时间：mNextMessageUptime =
messageEnvelope.uptime；也即下次被触发的时间。这个值也作为
3.1中调整epoll<sub>wait超时时间的值。</sub>
</p>
</li>

<li>invoke all response callback
　　对于回调函数不为空的情形，在事件触发后，就会自动执行调
用者提供的回调函数，如下面代码所示：

<div class="org-src-container">

<pre class="src src-c++"> // Invoke all response callbacks.
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        if (response.request.ident == ALOOPER_POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
            ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
                    this, response.request.callback.get(), fd, events, data);
#endif
            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd);
            }
            // Clear the callback reference in the response structure promptly because we
            // will not clear the response vector itself until the next poll.
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
</pre>
</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<p>
<b>三、Looper类应用实例分析</b>
</p>

<p>
　　下面来看下Looper类的API的使用。
</p>
<ol class="org-ol">
<li>Looper对象初始化
<div class="org-src-container">

<pre class="src src-c++">sp&lt;Looper&gt; mLooper = new Looper(true);
...
mLooper.clear();
</pre>
</div>
</li>
<li>pollOnece函数的使用
<div class="org-src-container">

<pre class="src src-c++">StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(1000);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>
<p>
返回值为 result = <code>ALOOPER_POLL_WAKE</code>
</p>
</li>
<li>设置CallBack
定义回调函数：
<div class="org-src-container">

<pre class="src src-c++">class CallbackHandler {
public:
    void setCallback(const sp&lt;Looper&gt;&amp; looper, int fd, int events) {
        looper-&gt;addFd(fd, 0, events, staticHandler, this);
    }

protected:
    virtual ~CallbackHandler() { }

    virtual int handler(int fd, int events) = 0;

private:
    static int staticHandler(int fd, int events, void* data) {
        return static_cast&lt;CallbackHandler*&gt;(data)-&gt;handler(fd, events);
    }
};

class StubCallbackHandler : public CallbackHandler {
public:
    int nextResult;
    int callbackCount;

    int fd;
    int events;

    StubCallbackHandler(int nextResult) : nextResult(nextResult),
            callbackCount(0), fd(-1), events(-1) {
    }

protected:
    virtual int handler(int fd, int events) {
        callbackCount += 1;
        this-&gt;fd = fd;
        this-&gt;events = events;
        return nextResult;
    }
};
</pre>
</div>

<p>
使用实例：
</p>
<div class="org-src-container">

<pre class="src src-c++">Pipe pipe;
StubCallbackHandler handler(true);

pipe.writeSignal();
handler.setCallback(mLooper, pipe.receiveFd, ALOOPER_EVENT_INPUT);

StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(100);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
　　...
</pre>
</div>

<p>
result的值为 <code>ALOOPER_POLL_CALLBACK</code> 。
</p>
</li>
<li>Callback为空的情形
　　若设置Callback为空，此时事件的标识符ident必须是一个大于或等
于0的值。如下代码所示：
<div class="org-src-container">

<pre class="src src-c++">const int expectedIdent = 5;
void* expectedData = this;

Pipe pipe;

pipe.writeSignal();
mLooper-&gt;addFd(pipe.receiveFd, expectedIdent, ALOOPER_EVENT_INPUT, NULL, expectedData);

StopWatch stopWatch("pollOnce");
int fd;
int events;
void* data;
int result = mLooper-&gt;pollOnce(100, &amp;fd, &amp;events, &amp;data);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>

<p>
此时返回值result等于ident的值。
</p>
</li>
<li>通过Looper发送消息
　　此种情况下一般不需要调用addFd，通过Looper默认创建的管道来监
听事件就行了。它的使用示例如下：
　　首先要定义一个MessageHandler的派生类，用于处理消息：
<div class="org-src-container">

<pre class="src src-c++">class StubMessageHandler : public MessageHandler {
public:
    Vector&lt;Message&gt; messages;

    virtual void handleMessage(const Message&amp; message) {
        messages.push(message);
    }
};
</pre>
</div>

<p>
接着就可以通过SendMessage相关的函数发送消息到Looper实例上：
</p>

<div class="org-src-container">

<pre class="src src-c++">nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
sp&lt;StubMessageHandler&gt; handler = new StubMessageHandler();
mLooper-&gt;sendMessageAtTime(now + ms2ns(100), handler, Message(MSG_TEST1));

StopWatch stopWatch("pollOnce");
int result = mLooper-&gt;pollOnce(1000);
int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());

...

result = mLooper-&gt;pollOnce(1000);
elapsedMillis = ns2ms(stopWatch.elapsedTime());

...
result = mLooper-&gt;pollOnce(100);
elapsedMillis = ns2ms(stopWatch.elapsedTime());
</pre>
</div>

<pre class="example">
第一次
elapsedMillis = 0;
result = ALOOPER_POLL_WAKE
Message size = 0;
第二次
elapsedMillis = 100
result = ALOOPER_POLL_CALLBACK
Message size = 1
第三次
result = ALOOPER_POLL_TIMEOUT
没有消息需要处理。
</pre>
</li>
</ol>
</div>
