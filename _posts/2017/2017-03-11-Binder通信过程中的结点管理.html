---
layout: post
date: 2017-03-11
author: 山庄来客
update: 2017-03-11
categories: android 软件开发
---
<div id="content">
<h1 class="title">Binder通信过程中的结点管理</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 概述</a></li>
<li><a href="#sec-2">2. linkToDeath(…)接口代码分析</a>
<ul>
<li><a href="#sec-2-1">2.1. linkToDeath方法调用的流程</a></li>
</ul>
</li>
<li><a href="#sec-3">3. unlinkToDeath代码流程分析</a>
<ul>
<li><a href="#sec-3-1">3.1. <b>unlinkToDeath(…)</b></a></li>
</ul>
</li>
<li><a href="#sec-4">4. IPC通信过程示例</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 概述</h2>
<div class="outline-text-2" id="text-1">
<p>
BpBinder类代表一个远程Binder对象（继承自BpRefBase）的通信功能部分。
它提供了linkToDeath方法，供其他对象监听自己所关联的本地结点的死亡
通知，本质上是通过调用IPCThreadState类的requestDeathNotification接
口。unlinkToDeath方法则是取消接收Binder结点的死亡通知。而
sendObituary则是向监听者发送结点的死亡通知。这两个接口都会通过
IPCThreadState类的clearDeathNotification将消息处理发送到Binder驱动
去处理。
</p>

<p>
一般BpBinder对象是包含于从BpRefBase继承过来的类中，也即BpINTERFACE
类的一个私有成员，代表IPC通信的一方与另一方进行通信。在Binder驱动，
要支持死亡通知机制，是通过 <code>binder_ref</code> 来实现的。 <code>binder_ref</code> 有一个成员
是指向 <code>struct binder_ref_death</code> 结构的指针。它的结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">struct binder_ref_death {
        struct binder_work work;
        binder_uintptr_t cookie;
};
</pre>
</div>

<p>
其中，work是指提交给当前线程或进程处理的工作类型，一般为如下三种：
</p>
<div class="org-src-container">

<pre class="src src-c">BINDER_WORK_DEAD_BINDER, //dead binder
BINDER_WORK_DEAD_BINDER_AND_CLEAR, //clear dead binder
BINDER_WORK_CLEAR_DEATH_NOTIFICATION, //clear death notification
</pre>
</div>

<p>
cookie则一般保存的是BpBinder对象的内存地址，主要用于标识当前的通信
会话。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> linkToDeath(…)接口代码分析</h2>
<div class="outline-text-2" id="text-2">
<p>
该接口的原型如下：
</p>
<div class="org-src-container">

<pre class="src src-c++">virtual status_t    linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient,
                                    void* cookie = NULL,
                                    uint32_t flags = 0);
</pre>
</div>

<p>
使用示例如下，SurfaceFlinger将监听window manager进程的死亡消息：
</p>
<div class="org-src-container">

<pre class="src src-c++">void SurfaceFlinger::bootFinished()
｛
        。。。
    // wait patiently for the window manager death
    const String16 name("window");
    sp&lt;IBinder&gt; window(defaultServiceManager()-&gt;getService(name));
    if (window != 0) {
        window-&gt;linkToDeath(static_cast&lt;IBinder::DeathRecipient*&gt;(this));
    }
        。。。
｝
</pre>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> linkToDeath方法调用的流程</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-plantuml">@startuml
[ -&gt; BpBinder: linkToDeath
BpBinder -&gt; IPCThreadState: requestDeathNotification
IPCThreadState -&gt; Binder Driver: BC_REQUEST_DEATH_NOTIFICATION
@enduml
</pre>
</div>


<div class="figure">
<p><img src="/images/2016/2016072801.png" alt="2016072801.png" />
</p>
</div>

<p>
下面看下处理 <code>BC_REQUEST_DEATH_NOTIFICATION</code> 的代码逻辑：
</p>

<p>
由于requestDeathNotification方法传入的两个参数一个是远程Binder结点
的句柄以及对象本身的内存地址（BpBinder对象），所以驱动依次拿到这两
个参数：
</p>

<div class="org-src-container">

<pre class="src src-c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                        binder_uintptr_t binder_buffer, size_t size,
                        binder_size_t *consumed)
{
  …
 case BC_REQUEST_DEATH_NOTIFICATION:
 case BC_CLEAR_DEATH_NOTIFICATION: {
   uint32_t target;
   binder_uintptr_t cookie;
   struct binder_ref *ref;
   struct binder_ref_death *death;

   if (get_user(target, (uint32_t __user *)ptr))
     return -EFAULT;
   ptr += sizeof(uint32_t);
   if (get_user(cookie, (binder_uintptr_t __user *)ptr))
     return -EFAULT;
   ptr += sizeof(binder_uintptr_t);
   //其中通过第一个参数在当前进程找到对应的binder_ref实例，
     ref = binder_get_ref(proc, target);

     //下面是处理BC_REQUEST_DEATH_NOTIFICATION的代码：

     if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
       如果ref-&gt;death不为空，则说明之前已经调用过requestDeathNotification，直接忽略这次调用。
         if (ref-&gt;death) {
           binder_user_error("%d:%d BC_REQUEST_DEATH_NOTIFICATION death notification already set\n",
                             proc-&gt;pid, thread-&gt;pid);
           break;
         }
       //否则，则创建一个binder_ref_death实例，并绑定给上述的binder_ref实例。
         death = kzalloc(sizeof(*death), GFP_KERNEL);
       if (death == NULL) {
         thread-&gt;return_error = BR_ERROR;
         binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
                      "%d:%d BC_REQUEST_DEATH_NOTIFICATION failed\n",
                      proc-&gt;pid, thread-&gt;pid);
         break;
       }
       binder_stats_created(BINDER_STAT_DEATH);
       INIT_LIST_HEAD(&amp;death-&gt;work.entry);
       death-&gt;cookie = cookie;
       ref-&gt;death = death;
       //如果远程Binder结点所在的进程已经退出，则说明远程Binder结点已经死亡，应该发送死亡通知，是通过与之关联的binder_ref的死亡列表发送通知的。
         if (ref-&gt;node-&gt;proc == NULL) {
           ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;
           // 如果当前线程没有退出，就发送到线程的事件处理链表中，否则发送到进程的事件处理链表中。
             if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
               list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);
             } else {
               list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);
               wake_up_interruptible(&amp;proc-&gt;wait);
             }
         }
     }
     //这里说明下，当ref-&gt;death-&gt;work.entry链表为空，说明binder_ref关联的远程Binder结点还处于活跃状态，无需发送死亡通知。
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> unlinkToDeath代码流程分析</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> <b>unlinkToDeath(…)</b></h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-plantuml">@startuml
[ -&gt; BpBinder: unlinkToDeath
BpBinder -&gt; IPCThreadState: clearDeathNotification
IPCThreadState -&gt; Binder Driver: BC_CLEAR_DEATH_NOTIFICATION
@enduml
</pre>
</div>


<div class="figure">
<p><img src="/images/2016/2016072802.png" alt="2016072802.png" />
</p>
</div>


<p>
下面来看处理 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 的逻辑。
</p>

<p>
发出这个命令的情形有两种：
</p>
<ol class="org-ol">
<li>结点没有死亡，此时提交的工作类型为
<code>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</code> ，只是取消监听结点的死亡通知，
不影响其他对象对该结点的监听。
</li>
<li>结点已经死亡，此时提交的工作类型为
<code>BINDER_WORK_DEAD_BINDER_AND_CLEAR</code> ，
这时是要清除。

<div class="org-src-container">

<pre class="src src-c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                        binder_uintptr_t binder_buffer, size_t size,
                        binder_size_t *consumed)
{
  …
 case BC_REQUEST_DEATH_NOTIFICATION:
 case BC_CLEAR_DEATH_NOTIFICATION: {
   …
     if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
       …
         } else {
       if (ref-&gt;death == NULL) {
         binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification not active\n",
                           proc-&gt;pid, thread-&gt;pid);
         break;
       }
       death = ref-&gt;death;
       //通过cookie来标识当前通信会话
         if (death-&gt;cookie != cookie) {
           binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification cookie mismatch %016llx != %016llx\n",
                             proc-&gt;pid, thread-&gt;pid,
                             (u64)death-&gt;cookie, (u64)cookie);
           break;
         }
       ref-&gt;death = NULL;
       // ''如果death-&gt;work.entry为空，说明被监听的Binder结点还处于活跃状态，这时只是取消对该结点的死亡监听
         if (list_empty(&amp;death-&gt;work.entry)) {
           death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
           if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
             list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
           } else {
             list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
             wake_up_interruptible(&amp;proc-&gt;wait);
           }
         } else {
           //  否则，该结点已经死亡，将当前工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR
             BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);
           death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;
         }
     }

   …
     }
</pre>
</div>

<p>
如下是处于当前线程或进程上的 <code>binder_work</code> 的处理过程：
</p>
<div class="org-src-container">

<pre class="src src-c">static int binder_thread_read(struct binder_proc *proc,
                              struct binder_thread *thread,
                              binder_uintptr_t binder_buffer, size_t size,
                              binder_size_t *consumed, int non_block)
{
  …
    while (1) {
      …
        //从当前线程或进程中取出提交上来的工作类型
        if (!list_empty(&amp;thread-&gt;todo))
          w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
          w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);
        else {
          …
            }
      …
        switch (w-&gt;type) {
          …
        case BINDER_WORK_DEAD_BINDER:
        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
          struct binder_ref_death *death;
          uint32_t cmd;

          death = container_of(w, struct binder_ref_death, work);
          if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)
            //被监听的结点没有死亡，通知用户空间减少对该结点的弱引用计数
              cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;
          else
            //被监听的结点已经死亡，发送BR_DEAD_BINDER通知用户空间处理
              cmd = BR_DEAD_BINDER;
          if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
          ptr += sizeof(uint32_t);
          if (put_user(death-&gt;cookie,
                       (binder_uintptr_t __user *)ptr))
            return -EFAULT;
          ptr += sizeof(binder_uintptr_t);
          binder_stat_br(proc, thread, cmd);
          binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
                       "%d:%d %s %016llx\n",
                       proc-&gt;pid, thread-&gt;pid,
                       cmd == BR_DEAD_BINDER ?
                       "BR_DEAD_BINDER" :
                       "BR_CLEAR_DEATH_NOTIFICATION_DONE",
                       (u64)death-&gt;cookie);

          if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {
            //这种情况是要删除death实例
              list_del(&amp;w-&gt;entry);
            kfree(death);
            binder_stats_deleted(BINDER_STAT_DEATH);
          } else
            // 将death实例的清理工作，提交到进程中延后处理（在收到BC_DEAD_BINDER_DONE时处理）
              list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);
          //由于BR_DEAD_BINDER还要触发用户空间向Binder驱动发送后续命令BC_CLEAR_DEATH_NOTIFICATION， BC_DEAD_BINDER_DONE， 所以应当退出当前循环，以便当前线程能够处理上述命令。
            if (cmd == BR_DEAD_BINDER)
              goto done; /* DEAD_BINDER notifications can cause transactions */
        } break;
        }
      …
        }
</pre>
</div>

<p>
如果在requestDeathNotification的时候结点已经退出，或Binder通信
结束，Binder结点被释放，调用了 <code>binder_node_release</code> ，驱动会返回
<code>BR_DEAD_BINDER</code> 命令，通知上层处理。
</p>
<div class="org-src-container">

<pre class="src src-c++">status_t IPCThreadState::executeCommand(int32_t cmd)
｛
        。。。
    case BR_DEAD_BINDER:
        {
            BpBinder *proxy = (BpBinder*)mIn.readInt32();
            proxy-&gt;sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writeInt32((int32_t)proxy);
        } break;
        。。。
｝
</pre>
</div>

<p>
首先，代表远程结点通信的BpBinder会调用sendObituary命令，清除对
它的死亡通知列表（会向驱动发送 <code>BC_CLEAR_DEATH_NOTIFICATION</code> 命
令），并调用监听者的回调函数通知监听者。之后，会向驱动发送
<code>BC_DEAD_BINDER_DONE</code> ，通知驱动善后处理。
</p>

<p>
下面看下 <code>BC_DEAD_BINDER_DONE</code> 的处理过程：
</p>
<div class="org-src-container">

<pre class="src src-c">case BC_DEAD_BINDER_DONE: {
  struct binder_work *w;
  binder_uintptr_t cookie;
  struct binder_ref_death *death = NULL;
  if (get_user(cookie, (binder_uintptr_t __user *)ptr))
    return -EFAULT;

  ptr += sizeof(void *);
  //从当前进程的延迟处理列表中，取出要处理的工作类型
    list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) {
    struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);
    //通过cookie来新知识对应的binder_ref_death实例
      if (tmp_death-&gt;cookie == cookie) {
        death = tmp_death;
        break;
      }
  }
  binder_debug(BINDER_DEBUG_DEAD_BINDER,
               "%d:%d BC_DEAD_BINDER_DONE %016llx found %p\n",
               proc-&gt;pid, thread-&gt;pid, (u64)cookie, death);
  //如果相关信息无法找到，则直接退出，无需后续处理
    if (death == NULL) {
      binder_user_error("%d:%d BC_DEAD_BINDER_DONE %016llx not found\n",
                        proc-&gt;pid, thread-&gt;pid, (u64)cookie);
      break;
    }

  list_del_init(&amp;death-&gt;work.entry);
  //结点已经死亡，需要清理消息通知相关信息
    if (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {
      death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
      if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
      } else {
        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
        wake_up_interruptible(&amp;proc-&gt;wait);
      }
    }
} break;
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> IPC通信过程示例</h2>
<div class="outline-text-2" id="text-4">
<pre class="example">
BC_DEAD_BINDER(binder_node_release或BC_REQUEST_DEATH_NOTIFICATION)
-&gt;BR_DEAD_BINDER(binder_thread_read)
-&gt; BC_CLEAR_DEATH_NOTIFICATION（如果结点已经死亡，则工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR）
-&gt; BC_DEAD_BINDER_DONE（将工作类型修改为BINDER_WORK_CLEAR_DEATH_NOTIFICATION，提交到当前线程或进程进一步处理）
-&gt; BR_CLEAR_DEATH_NOTIFICATION_DONE
</pre>
</div>
</div>
</div>
